<class name = "fmq_server" script = "server_c" codec = "fmq_msg">
FileMQ protocol server
<include filename = "license.xml" />

<state name = "start">
    <event name = "OHAI" next = "checking client">
        <action name = "track client identity" />
        <action name = "try anonymous access" />
    </event>
</state>

<state name = "checking client">
    <event name = "friend" next = "ready">
        <action name = "send" message ="OHAI-OK" />
    </event>
    <event name = "foe">
        <action name = "send" message = "SRSLY" />
        <action name = "terminate the client" />
    </event>
    <event name = "maybe" next = "challenging client">
        <action name = "list security mechanisms" />
        <action name = "send" message = "ORLY" />
    </event>
</state>

<state name = "challenging client">
    <event name = "YARLY" next = "checking client">
        <action name = "try security mechanism" />
    </event>
</state>

<state name = "ready">
    <event name = "ICANHAZ">
        <action name = "store client subscription" />
        <action name = "send" message = "ICANHAZ-OK" />
    </event>
    <event name = "NOM" next = "dispatching">
        <action name = "store client credit" />
        <action name = "get next patch for client" />
    </event>
    <event name = "HUGZ">
        <action name = "send" message = "HUGZ-OK" />
    </event>
    <event name = "KTHXBAI">
        <action name = "terminate the client" />
    </event>
    <event name = "dispatch" next = "dispatching">
        <action name = "get next patch for client" />
    </event>
    <event name = "heartbeat">
        <action name = "send" message = "HUGZ" />
    </event>
</state>

<state name = "dispatching">
    <event name = "send chunk">
        <action name = "send" message = "CHEEZBURGER" />
        <action name = "get next patch for client" />
    </event>
    <event name = "send delete">
        <action name = "send" message = "CHEEZBURGER" />
        <action name = "get next patch for client" />
    </event>
    <event name = "next patch">
        <action name = "get next patch for client" />
    </event>
    <event name = "no credit" next = "ready" />
    <event name = "finished" next = "ready" />
</state>

<state name = "defaults">
    <event name = "heartbeat" />
    <event name = "expired">
        <action name = "terminate the client" />
    </event>
    <event name = "$other">
        <action name = "send" message = "RTFM" />
        <action name = "terminate the client" />
    </event>
</state>

<!-- Server and client contexts -->
<declare>
//  There's no point making these configurable
#define CHUNK_SIZE      1000000
</declare>


<self>
<context>
zlist_t *subs;              //  Client subscriptions
zlist_t *mounts;            //  Mount points
</context>

<construct>
//  Default root
self->subs = zlist_new ();
self->mounts = zlist_new ();
</construct>

<destruct>
//  Destroy subscriptions
while (zlist_size (self->subs)) {
    sub_t *sub = (sub_t *) zlist_pop (self->subs);
    sub_destroy (&sub);
}
zlist_destroy (&self->subs);

//  Destroy mount points
while (zlist_size (self->mounts)) {
    mount_t *mount = (mount_t *) zlist_pop (self->mounts);
    mount_destroy (&mount);
}
zlist_destroy (&self->mounts);
</destruct>
</self>


<client>
<context>
byte identity [FMQ_MSG_IDENTITY_SIZE];
size_t credit;              //  Credit remaining
zlist_t *patches;           //  Patches to send
fmq_patch_t *patch;         //  Current patch
fmq_file_t *file;           //  Current file we're sending
off_t offset;               //  Offset of next read in file
int64_t sequence;           //  Sequence number for chunk
</context>

<construct>
self->patches = zlist_new ();
</construct>

<destruct>
while (zlist_size (self->patches)) {
    fmq_patch_t *patch = (fmq_patch_t *) zlist_pop (self->patches);
    fmq_patch_destroy (&patch);
}
zlist_destroy (&self->patches);
</destruct>
</client>

<!-- Embedded class for subscriptions -->
<include filename = "fmq_server_sub.xml" />
<!-- Embedded class for mount points -->
<include filename = "fmq_server_mount.xml" />

<!-- Action bodies -->
<action name = "terminate the client">
//  Remove all subscriptions for this client
sub_t *sub = (sub_t *) zlist_first (self->subs);
while (sub) {
    if (sub->client == client) {
        sub_t *next = (sub_t *) zlist_next (self->subs);
        zlist_remove (self->subs, sub);
        sub_destroy (&sub);
        sub = next;
    }
    else
        sub = (sub_t *) zlist_next (self->subs);
}
client->next_event = terminate_event;
</action>

<action name = "track client identity">
memcpy (client->identity, fmq_msg_identity (client->request), FMQ_MSG_IDENTITY_SIZE);
</action>

<action name = "try anonymous access">
if (atoi (fmq_config_resolve (self->config, "security/anonymous", "0")) == 1)
    client->next_event = friend_event;
else
if (atoi (fmq_config_resolve (self->config, "security/plain", "0")) == 1)
    client->next_event = maybe_event;
else
    client->next_event = foe_event;
</action>
    
<action name = "list security mechanisms">
if (atoi (fmq_config_resolve (self->config, "security/anonymous", "0")) == 1)
    fmq_msg_mechanisms_append (client->reply, "ANONYMOUS");
if (atoi (fmq_config_resolve (self->config, "security/plain", "0")) == 1)
    fmq_msg_mechanisms_append (client->reply, "PLAIN");
</action>

<action name = "try security mechanism">
client->next_event = foe_event;
char *login, *password;
if (streq (fmq_msg_mechanism (client->request), "PLAIN")
&&  fmq_sasl_plain_decode (fmq_msg_response (client->request), &login, &password) == 0) {
    fmq_config_t *account = fmq_config_locate (self->config, "security/plain/account");
    while (account) {
        if (streq (fmq_config_resolve (account, "login", ""), login)
        &&  streq (fmq_config_resolve (account, "password", ""), password)) {
            client->next_event = friend_event;
            break;
        }
        account = fmq_config_next (account);
    }
}
free (login);
free (password);
</action>

<action name = "store client subscription">
//  Store subscription along with any previous ones
//  Check we don't already have a subscription for this client/path
sub_t *sub = (sub_t *) zlist_first (self->subs);
char *path = fmq_msg_path (client->request);
while (sub) {
    if (client == sub->client && streq (path, sub->path))
        return;
    sub = (sub_t *) zlist_next (self->subs);
}
//  New subscription for this client, append to our list
sub = sub_new (client, fmq_msg_path (client->request));
zlist_append (self->subs, sub);
</action>

<action name = "store client credit">
client->credit += fmq_msg_credit (client->request);
</action>

<!-- Hook actions -->
<declare>
//  Client hash function that checks if client is alive
static int
client_dispatch (const char *key, void *client, void *server)
{
    server_client_execute ((server_t *) server, (client_t *) client, dispatch_event);
    return 0;
}
</declare>

<action name = "monitor the server">
mount_t *mount = (mount_t *) zlist_first (self->mounts);
while (mount) {
    if (mount_refresh (mount, self))
        zhash_foreach (self->clients, client_dispatch, self);
    mount = (mount_t *) zlist_next (self->mounts);
}
</action>

<action name = "get next patch for client">
//  Get next patch for client if we're not doing one already
if (client->patch == NULL)
    client->patch = (fmq_patch_t *) zlist_pop (client->patches);
if (client->patch == NULL) {
    client->next_event = finished_event;
    return;
}
//  Map filename to logical space by removing server root
char *rootdir = fmq_config_resolve (self->config, "server/root", "./fmqroot");
char *filename = fmq_file_name (fmq_patch_file (client->patch), rootdir);
fmq_msg_filename_set (client->reply, filename);

//  We can process a delete patch right away
if (fmq_patch_op (client->patch) == patch_delete) {
    fmq_msg_sequence_set (client->reply, client->sequence++);
    fmq_msg_operation_set (client->reply, FMQ_MSG_FILE_DELETE);
    client->next_event = send_delete_event;
    
    //  No reliability in this version, assume patch delivered safely
    fmq_patch_destroy (&client->patch);
}
else {
    //  Create patch refers to file, open that for input if needed
    if (client->file == NULL) {
        client->file = fmq_file_dup (fmq_patch_file (client->patch));
        if (fmq_file_input (client->file)) {
            //  File no longer available, skip it
            fmq_patch_destroy (&client->patch);
            fmq_file_destroy (&client->file);
            client->next_event = next_patch_event;
            return;
        }
        client->offset = 0;
    }
    //  Get next chunk for file
    fmq_chunk_t *chunk = fmq_file_read (client->file, CHUNK_SIZE, client->offset);
    assert (chunk);

    //  Check if we have the credit to send chunk
    if (fmq_chunk_size (chunk) <= client->credit) {
        fmq_msg_sequence_set (client->reply, client->sequence++);
        fmq_msg_operation_set (client->reply, FMQ_MSG_FILE_CREATE);
        fmq_msg_offset_set (client->reply, client->offset);
        fmq_msg_chunk_set (client->reply, zframe_new (
            fmq_chunk_data (chunk),
            fmq_chunk_size (chunk)));
        
        client->offset += fmq_chunk_size (chunk);
        client->credit -= fmq_chunk_size (chunk);
        client->next_event = send_chunk_event;
        
        //  Zero-sized chunk means end of file
        if (fmq_chunk_size (chunk) == 0) {
            fmq_file_destroy (&client->file);
            fmq_patch_destroy (&client->patch);
        }
    }
    else
        client->next_event = no_credit_event;
        
    fmq_chunk_destroy (&chunk);
}
</action>


<!-- API methods -->
<method name = "bind">
<argument name = "endpoint" type = "string" />
zmq_bind (self->router, endpoint);
</method>

<method name = "publish">
<argument name = "path" type = "string" />
//  Discard any mounts that have overlapping paths
mount_t *mount = (mount_t *) zlist_first (self->mounts);
while (mount) {
    if (strncmp (mount->path, path, strlen (path)) == 0
    ||  strncmp (mount->path, path, strlen (mount->path)) == 0) {
        zclock_log ("W: overlapping mount point '%s' - ignored\n", path);
        break;
    }
    mount = (mount_t *) zlist_next (self->mounts);
}
//  Only create new mount if we didn't hit a duplicate
if (!mount) {
    mount = mount_new (
        fmq_config_resolve (self->config, "server/root", "./fmqroot"), path);
    zlist_append (self->mounts, mount);
}
</method>

<include filename = "fmq_server_selftest.xml" />

<!-- TODO
    allow mount points to overlap
        - allow subscriptions to overlap
        - filter duplicates to one client
        
    store patch list per client
        use client identifier, not real id
        test client disconnect & reconnect
    
    - on exit
        save directory tree to disk
        save patch list to disk
    - on startup
        load directory tree from disk
        load patch list from disk
    - list serialization code generator?
    
    some protocol for getting initial directory
    subscribe option
        to get all files?
        what if some already exist?
        not rsync protocol... 
    
-->

</class>

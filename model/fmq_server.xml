<class name = "fmq_server" script = "server_c" codec = "fmq_msg">
FileMQ protocol server
<include filename = "license.xml" />

<state name = "start">
    <event name = "OHAI" next = "checking client">
        <action name = "track client identity" />
        <action name = "try anonymous access" />
    </event>
</state>

<state name = "checking client">
    <event name = "friend" next = "ready">
        <action name = "send" message ="OHAI-OK" />
    </event>
    <event name = "foe">
        <action name = "send" message = "SRSLY" />
        <action name = "terminate the client" />
    </event>
    <event name = "maybe" next = "challenging client">
        <action name = "list security mechanisms" />
        <action name = "send" message = "ORLY" />
    </event>
</state>

<state name = "challenging client">
    <event name = "YARLY" next = "checking client">
        <action name = "try security mechanism" />
    </event>
</state>

<state name = "ready">
    <event name = "ICANHAZ">
        <action name = "store client subscription" />
        <action name = "send" message = "ICANHAZ-OK" />
    </event>
    <event name = "NOM" next = "dispatching">
        <action name = "store client credit" />
        <action name = "get next patch for client" />
    </event>
    <event name = "HUGZ">
        <action name = "send" message = "HUGZ-OK" />
    </event>
    <event name = "KTHXBAI">
        <action name = "terminate the client" />
    </event>
    <event name = "dispatch" next = "dispatching">
        <action name = "get next patch for client" />
    </event>
    <event name = "heartbeat">
        <action name = "send" message = "HUGZ" />
    </event>
</state>

<state name = "dispatching">
    <event name = "ok">
        <action name = "send" message = "CHEEZBURGER" />
        <action name = "get next patch for client" />
    </event>
    <event name = "finished" next = "ready" />
</state>

<state name = "defaults">
    <event name = "heartbeat" />
    <event name = "expired">
        <action name = "terminate the client" />
    </event>
    <event name = "$other">
        <action name = "send" message = "RTFM" />
        <action name = "terminate the client" />
    </event>
</state>

<!-- Server and client contexts -->
<self>
<context>
zlist_t *subs;              //  Client subscriptions
zlist_t *mounts;            //  Mount points
</context>
<construct>
//  Default root
self->subs = zlist_new ();
self->mounts = zlist_new ();
</construct>
<destruct>
//  Destroy subscriptions
while (zlist_size (self->subs)) {
    sub_t *sub = (sub_t *) zlist_pop (self->subs);
    sub_destroy (&sub);
}
zlist_destroy (&self->subs);

//  Destroy mount points
while (zlist_size (self->mounts)) {
    mount_t *mount = (mount_t *) zlist_pop (self->mounts);
    mount_destroy (&mount);
}
zlist_destroy (&self->mounts);
</destruct>
</self>

<client>
<context>
byte identity [FMQ_MSG_IDENTITY_SIZE];
size_t credit;              //  Credit remaining
zlist_t *patches;           //  Patches to send
size_t patch_nbr;           //  Sequence number
</context>
<construct>
self->patches = zlist_new ();
</construct>
<destruct>
while (zlist_size (self->patches)) {
    fmq_patch_t *patch = (fmq_patch_t *) zlist_pop (self->patches);
    fmq_patch_destroy (&patch);
}
zlist_destroy (&self->patches);
</destruct>
</client>

<!-- Embedded class for subscriptions -->
<include filename = "fmq_server_sub.xml" />
<!-- Embedded class for mount points -->
<include filename = "fmq_server_mount.xml" />

<!-- Action bodies -->
<action name = "terminate the client">
//  Remove all subscriptions for this client
sub_t *sub = (sub_t *) zlist_first (self->subs);
while (sub) {
    if (sub->client == client) {
        sub_t *next = (sub_t *) zlist_next (self->subs);
        zlist_remove (self->subs, sub);
        sub_destroy (&sub);
        sub = next;
    }
    else
        sub = (sub_t *) zlist_next (self->subs);
}
client->next_event = terminate_event;
</action>

<action name = "track client identity">
memcpy (client->identity, fmq_msg_identity (client->request), FMQ_MSG_IDENTITY_SIZE);
</action>

<action name = "try anonymous access">
if (atoi (fmq_config_resolve (self->config, "security/anonymous", "0")) == 1)
    client->next_event = friend_event;
else
if (atoi (fmq_config_resolve (self->config, "security/plain", "0")) == 1)
    client->next_event = maybe_event;
else
    client->next_event = foe_event;
</action>
    
<action name = "list security mechanisms">
if (atoi (fmq_config_resolve (self->config, "security/anonymous", "0")) == 1)
    fmq_msg_mechanisms_append (client->reply, "ANONYMOUS");
if (atoi (fmq_config_resolve (self->config, "security/plain", "0")) == 1)
    fmq_msg_mechanisms_append (client->reply, "PLAIN");
</action>

<action name = "try security mechanism">
client->next_event = foe_event;
char *login, *password;
if (streq (fmq_msg_mechanism (client->request), "PLAIN")
&&  fmq_sasl_plain_decode (fmq_msg_response (client->request), &login, &password) == 0) {
    fmq_config_t *account = fmq_config_locate (self->config, "security/plain/account");
    while (account) {
        if (streq (fmq_config_resolve (account, "login", ""), login)
        &&  streq (fmq_config_resolve (account, "password", ""), password)) {
            client->next_event = friend_event;
            break;
        }
        account = fmq_config_next (account);
    }
}
free (login);
free (password);
</action>

<action name = "store client subscription">
//  Store subscription along with any previous ones
//  Check we don't already have a subscription for this client/path
sub_t *sub = (sub_t *) zlist_first (self->subs);
char *path = fmq_msg_path (client->request);
while (sub) {
    if (client == sub->client && streq (path, sub->path))
        return;
    sub = (sub_t *) zlist_next (self->subs);
}

//  New subscription for this client, append to our list
sub = sub_new (client, fmq_msg_path (client->request));
zlist_append (self->subs, sub);
</action>

<action name = "store client credit">
client->credit += fmq_msg_credit (client->request);
</action>

<!-- Hook actions -->
<declare>
//  Client hash function that checks if client is alive
static int
client_dispatch (const char *key, void *client, void *server)
{
    server_client_execute ((server_t *) server, (client_t *) client, dispatch_event);
    return 0;
}
</declare>
<action name = "monitor the server">
mount_t *mount = (mount_t *) zlist_first (self->mounts);
while (mount) {
    if (mount_refresh (mount, self))
        zhash_foreach (self->clients, client_dispatch, self);
    mount = (mount_t *) zlist_next (self->mounts);
}
</action>

<action name = "get next patch for client">
fmq_patch_t *patch = (fmq_patch_t *) zlist_pop (client->patches);
if (patch) {
    client->next_event = ok_event;
    switch (fmq_patch_op (patch)) {
        case patch_create:
            fmq_msg_operation_set (client->reply, FMQ_MSG_FILE_CREATE);
            printf ("I: created: %s\n", fmq_file_name (fmq_patch_file (patch)));
            break;
        case patch_delete:
            fmq_msg_operation_set (client->reply, FMQ_MSG_FILE_DELETE);
            printf ("I: deleted: %s\n", fmq_file_name (fmq_patch_file (patch)));
            break;
        case patch_resize:
            fmq_msg_operation_set (client->reply, FMQ_MSG_FILE_RESIZE);
            printf ("I: changed: %s\n", fmq_file_name (fmq_patch_file (patch)));
            break;
        case patch_retime:
            fmq_msg_operation_set (client->reply, FMQ_MSG_FILE_RETIME);
            printf ("I: touched: %s\n", fmq_file_name (fmq_patch_file (patch)));
            break;
    }
    fmq_msg_filename_set (client->reply, fmq_file_name (fmq_patch_file (patch)));
}
else
    client->next_event = finished_event;
</action>


<!-- API methods -->
<method name = "bind">
<argument name = "endpoint" type = "string" />
zmq_bind (self->router, endpoint);
</method>

<method name = "connect">
<argument name = "endpoint" type = "string" />
zmq_connect (self->router, endpoint);
</method>

<method name = "mount">
<argument name = "path" type = "string" />
mount_t *mount = mount_new (
    fmq_config_resolve (self->config, "server/root", "./fmqroot"), path);
zlist_append (self->mounts, mount);
</method>

<include filename = "fmq_server_selftest.xml" />

<!-- TODO
    server:
    
    - client has to tell server last patch PATCH ID
    - server applies patches since last PATCH ID
    - push patches to clients
    - patch id is sequence number
    - change protocol to be a patch protocol
    - test on sending growing files...
        - streaming?
    - on exit
        save directory tree to disk
        save patch list to disk
    - on startup
        load directory tree from disk
        load patch list from disk
    - list serialization code generator?

    store patch list per client
        use client identifier, not real id
        test client disconnect & reconnect

    some protocol for getting initial directory
    subscribe option
        to get all files?
        what if some already exist?
        not rsync protocol... 
    
    client:
    - confirm applied patches

-->

</class>

<declare>
//  Mount point in memory
typedef struct {
    char *local;            //  Local path
    char *virtual;          //  Virtual path
    fmq_dir_t *dir;         //  Directory tree

    //  Directory signature
    time_t time;            //  Modification time
    off_t  size;            //  Total file size
    size_t count;           //  Total file count

    //  List of patches to directory
    zlist_t *patches;       //  fmq_patch_t items
} mount_t;

//  Constructor
//  Loads directory tree if possible

static mount_t *
mount_new (char *local, char *virtual)
{
    mount_t *self = (mount_t *) zmalloc (sizeof (mount_t));
    self->local = strdup (local);
    self->virtual = strdup (virtual);
    self->dir = fmq_dir_new (self->local, NULL);
    self->patches = zlist_new ();
    return self;
}

//  Destructor

static void
mount_destroy (mount_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mount_t *self = *self_p;
        free (self->local);
        free (self->virtual);
        while (zlist_size (self->patches)) {
            fmq_patch_t *patch = (fmq_patch_t *) zlist_pop (self->patches);
            fmq_patch_destroy (&patch);
        }
        zlist_destroy (&self->patches);
        fmq_dir_destroy (&self->dir);
        free (self);
        *self_p = NULL;
    }
}

//  Reloads directory tree and returns true if changed, false if the same.

static bool
mount_refresh (mount_t *self)
{
    //  Get latest snapshot and build a patches list if it's changed
    fmq_dir_t *latest = fmq_dir_new (self->local, NULL);
    zlist_t *patches = fmq_dir_diff (self->dir, latest);

    //  Drop old directory and replace with latest version
    fmq_dir_destroy (&self->dir);
    self->dir = latest;

    //  Move new patches to mount patches list
    //  If we had a previous operation on same file, remove that
    while (zlist_size (patches)) {
        fmq_patch_t *patch = (fmq_patch_t *) zlist_pop (patches);
        //  Trace activity; we'll make this configurable later
        switch (fmq_patch_op (patch)) {
            case patch_create:
                printf ("I: created: %s\n", fmq_file_name (fmq_patch_file (patch)));
                break;
            case patch_delete:
                printf ("I: deleted: %s\n", fmq_file_name (fmq_patch_file (patch)));
                break;
            case patch_resize:
                printf ("I: changed: %s\n", fmq_file_name (fmq_patch_file (patch)));
                break;
            case patch_retime:
                printf ("I: touched: %s\n", fmq_file_name (fmq_patch_file (patch)));
                break;
        }
        //  Remove old patch if any, for same file name
        fmq_patch_t *check = (fmq_patch_t *) zlist_first (self->patches);
        while (check) {
            if (streq (fmq_file_name (fmq_patch_file (patch)),
                       fmq_file_name (fmq_patch_file (check)))) {
                zlist_remove (self->patches, check);
                break;
            }
            else
                check = (fmq_patch_t *) zlist_next (self->patches);
        }
        zlist_append (self->patches, patch);
    }
    zlist_destroy (&patches);
    return false;
}
</declare>

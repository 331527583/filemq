<declare>
//  --------------------------------------------------------------------------
//  Mount point in memory

typedef struct {
    char *fullpath;         //  Root + path
    char *path;             //  Path (after root)
    fmq_dir_t *dir;         //  Directory tree
} mount_t;


//  --------------------------------------------------------------------------
//  Constructor
//  Loads directory tree if possible

static mount_t *
mount_new (char *root, char *path)
{
    //  Mount path must start with '/'
    //  We'll do better error handling later
    assert (*path == '/');
    
    mount_t *self = (mount_t *) zmalloc (sizeof (mount_t));
    self->fullpath = (char *) malloc (strlen (root) + strlen (path) + 1);
    sprintf (self->fullpath, "%s%s", root, path);
    self->path = strdup (path);
    self->dir = fmq_dir_new (self->fullpath, NULL);
    return self;
}


//  --------------------------------------------------------------------------
//  Destructor

static void
mount_destroy (mount_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mount_t *self = *self_p;
        free (self->fullpath);
        free (self->path);
        fmq_dir_destroy (&self->dir);
        free (self);
        *self_p = NULL;
    }
}


//  --------------------------------------------------------------------------
//  Reloads directory tree and returns true if changed, false if the same

static bool
mount_refresh (mount_t *self, server_t *server)
{
    bool changed = false;

    //  Get latest snapshot and build a patches list if it's changed
    fmq_dir_t *latest = fmq_dir_new (self->fullpath, NULL);
    zlist_t *patches = fmq_dir_diff (self->dir, latest);

    //  Drop old directory and replace with latest version
    fmq_dir_destroy (&self->dir);
    self->dir = latest;

    //  Copy new patches to clients' patches list
    //  TODO: remove any previous patches for same file name
    sub_t *sub = (sub_t *) zlist_first (server->subs);
    while (sub) {
        //  Is subscription path a strict prefix of the mount path?
        if (strncmp (self->path, sub->path, strlen (sub->path)) == 0) {
            fmq_patch_t *patch = (fmq_patch_t *) zlist_first (patches);
            while (patch) {
                zlist_append (sub->client->patches, fmq_patch_dup (patch));
                fmq_patch_set_number (patch, sub->client->patch_nbr++);
                patch = (fmq_patch_t *) zlist_next (patches);
                changed = true;
            }
        }
        sub = (sub_t *) zlist_next (server->subs);
    }
    zlist_destroy (&patches);
    return changed;
}
</declare>
